# Server CONTRIBUTING 
## Introduction

The "My Assignments" project is split up between two applications: the Uploader
and the Server. The Server is a web application that allows students to view 
their stored assignment PDFs. This document will guide you on how to contribute
to the Server application. 

## Perquisite Knowledge

The Server is written in Java 8 and is not backwards compatible with any other 
Java versions. Because it is heavily relied upon in much of the server code: it
is recommended that you look up documentation on
[Java 8 functional programming](https://flyingbytes.github.io/programming/java8/functional/part1/2017/01/23/Java8-Part1.html).
Additionally, the Server also relies upon the 
[Spark micro-web Framework](http://sparkjava.com/) to service web requests, and
[JOOQ](https://www.jooq.org/) to handle database calls.

The design of the API for handling the upload of student assignments and 
related metadata is based off of 
[REST](http://www.restapitutorial.com/lessons/whatisrest.html). The overall 
architecture of the application follows the 
[Model-View-Controller](https://blog.codinghorror.com/understanding-model-view-controller/).
design pattern. 

## Architecture
The main entry point for the Server application is `era.server.ServerApp`. 
`ServerApp` first parses command line options passed to it (through the use of
era.server.common.ConfigOpts) and "starts up" the `ServerWebModule` and 
the `UploaderAPIModule`. 

The application is split up into separate modules. Modules are groupings of 
functionality that are mostly independent from the rest of the application. We 
split up our modules based on the request routes that they handle. For example: 
`UploaderAPIModule` handles requests that are related to communication with an 
Uploader client application. All Module classes implement the `ServerModule` 
interface that requires modules to setup the request routes that they handle. 

The `ServerWebModule` sets up routes, using Spark's 
[HTTP verb methods](http://sparkjava.com/documentation#routes), to allow
students to use the Server web application. This includes viewing new  
assignments, logging in, and navigating through previous assignments. 
Controllers defined in `era.server.web` will handle requests for those routes.
We use [Handlebars.js](http://handlebarsjs.com/) for generating pages that 
students view. `era.server.common.PageRenderer` has a `#render` helper method to 
render Handlebars templates. 

The `UploaderAPIModule` sets up routes, using Spark's 
[HTTP verb methods](http://sparkjava.com/documentation#routes), to allow
the Uploader desktop application to communicate information to the Server. 
This information can include the assignments themselves as well as metadata 
about courses and students. Controllers defined in `era.server.api` will 
handle requests for those routes. 

`era.server.data.model` contains the Models used in this application. Models 
allow for storing domain specific information into a nice, tidy spot. Each 
model should implement the `era.server.data.model.Model` interface. This 
interface declares a method `#toViewModel` which allows the model to be used 
in Handlebar templates. 

`era.server.data.access` contains Data Access Objects (DAOs) that allow for 
the storage and retrieval of models stored in the my-assignments database. 

`era.server.data.database` contains classes generated by JOOQ. JOOQ is our ORM 
that provides us on API for communication with a database. It should only 
be used by the `era.server.data.access` package.   

## Routes

### Uploader API 

Each route belonging to the Uploader API is prefix with `/api/`. Routes are 
defined in the `UploaderAPIModule`. 

* `/api/course/:courseId/assignment` Creates an assignment. It takes in a POST
request with a Content-Type of `multipart/form-data`. It requires the custom 
headers of X-Assignment-Id (the id that the assignment will have when stored in
the database), X-Assignment-Name (the name of the assignment), X-Student-Id 
(the database id of the student who submitted the assignment), and 
X-Assignment-File-Name (the file name defining where the assignment should be 
stored at). `:courseId` is a request parameter that provides the database id 
for the course where the assignment was submitted to. The body should have a 
part with the name "pdf" that contains the actual assignment PDF file. 

* `/api/course/:courseId` Creates a course of students. It takes in a POST 
request with a Content-Type of `application/json`. The body should be a JSON 
list of `era.server.data.model.Course` objects. The `courseId` request 
parameter defines the database id of the course. The schema of the request is 
as follows:
```javascript 
[
    {
        "uniqueId", 
        "name", 
        "semester": {
            "uniqueId",
            "term", 
            "year"
        }, 
        "students": [
            {
                "userName", 
                "email", 
                "uniqueId"
        ]
    }
]
```

### Web pages
* `/hello` A health check page that should always respond "is it me you are 
looking for?". It just takes in a GET request with no parameters or headers. It
checks to make sure that the application can connect to the database.  

## Development workflow. 
This is the general workflow for adding a new feature to the server. 

1. Determine a request route that will be an entry point to this feature. This 
will be the path that users will request with either their web browser or 
indirectly through the Uploader application. 
    * If you are setting up a route that will be a part of the Uploader API 
    make sure to follow REST principles: basically name that route after the 
    model that the API will be manipulating. For instance a POST /api/grader 
    should more than likely create a new `Grader` object. 
2. Determine which module the route should go in. 
    * Currently the only two modules we have are the `UploaderAPIModule` and 
    the `ServerWebModule`. If the client of a request route will be the 
    Uploader desktop application, then most likely it belongs in the 
    `UploaderAPIModule`, otherwise it belongs in the `ServerWebModule`. 
3. Create a Controller method that will handle that route. 
    * Controller methods have to correspond to the signature of the 
    `spark.Route#handle` method in order be interoperable with 
    "Spark HTTP verb" methods 
    * the controller method should be mostly focused on parsing out request 
    information and creating a response. You may think about creating a 
    _Service_ if the controller is handling to much backend logic. 
4. In the Controller use classes in the `era.server.data.access` and 
`era.server.data.model` packages handle database operations. 
5. Use a Spark [HTTP verb method](http://sparkjava.com/documentation#routes) to
link that controller method to a request route
    * A good example would be ServerWebModule/HealthController. 
    * You will need to use a method reference on an instance of your 
    Controller. For example in `ServerWebModule` I instantiate 
    `HealthController` and use `healthController::checkHealth` to reference my 
    Controller method that handles checking of server health  
    * Look at 
    [http://www.restapitutorial.com/lessons/httpmethods.html](http://www.restapitutorial.com/lessons/httpmethods.html)
    to determine which HTTP verb to use. 
    